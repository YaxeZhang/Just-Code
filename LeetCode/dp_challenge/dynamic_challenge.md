|题号|题目名称|通关率|难度|zc打卡|jdq打卡|
|---|---|---|---|---|---|
|5|[Longest Palindromic Substring](#5-longest-palindromic-substring)<span id = 5></span>|29.3%|Medium||2020.07.22|
|10|[Regular Expression Matching](#10-regular-expression-matching)<span id = 10></span>|26.7%|Hard|2020.07.29||
|32|[Longest Valid Parentheses](#32-longest-valid-parentheses)<span id = 32></span>|28.2%|Hard|||
|44|[Wildcard Matching](#44-wildcard-matching)<span id = 44></span>|24.6%|Hard|||
|53|[Maximum Subarray](#53-maximum-subarray)<span id = 53></span>|46.4%|Easy|2020.07.20|2020.07.20|
|62|[Unique Paths](#62-unique-paths)<span id = 62></span>|53.8%|Medium|2020.07.15|2020.07.19|
|63|[Unique Paths II](#63-unique-paths-ii)<span id = 63></span>|34.4%|Medium|2020.07.15|2020.07.19|
|64|[Minimum Path Sum](#64-minimum-path-sum)<span id = 64></span>|54.1%|Medium|2020.07.15|2020.07.19|
|70|[Climbing Stairs](#70-climbing-stairs)<span id = 70></span>|47.1%|Easy|2020.07.15|2020.07.20|
|72|[Edit Distance](#72-edit-distance)<span id = 72></span>|44.4%|Hard|2020.07.15|2020.07.20|
|85|[Maximal Rectangle](#85-maximal-rectangle)<span id = 85></span>|37.4%|Hard|||
|87|[Scramble String](#87-scramble-string)<span id = 87></span>|33.6%|Hard|||
|91|[Decode Ways](#91-decode-ways)<span id = 91></span>|24.5%|Medium|||
|95|[Unique Binary Search Trees II](#95-unique-binary-search-trees-ii)<span id = 95></span>|40.3%|Medium|||
|96|[Unique Binary Search Trees](#96-unique-binary-search-trees)<span id = 96></span>|52.5%|Medium|2020.07.15|2020.07.19|
|97|[Interleaving String](#97-interleaving-string)<span id = 97></span>|31.3%|Hard|2020.07.28||
|115|[Distinct Subsequences](#115-distinct-subsequences)<span id = 115></span>|38.0%|Hard|2020.07.28||
|120|[Triangle](#120-triangle)<span id = 120></span>|43.8%|Medium|2020.07.16|2020.07.16|
|121|[Best Time to Buy and Sell Stock](#121-best-time-to-buy-and-sell-stock)<span id = 121></span>|50.3%|Easy|2020.07.16|2020.07.20|
|123|[Best Time to Buy and Sell Stock III](#123-best-time-to-buy-and-sell-stock-iii)<span id = 123></span>|37.2%|Hard|2020.07.21|2020.07.24|
|132|[Palindrome Partitioning II](#132-palindrome-partitioning-ii)<span id = 132></span>|30.1%|Hard|||
|139|[Word Break](#139-word-break)<span id = 139></span>|39.7%|Medium|2020.07.21|2020.07.21|
|140|[Word Break II](#140-word-break-ii)<span id = 140></span>|31.5%|Hard|2020.07.22||
|152|[Maximum Product Subarray](#152-maximum-product-subarray)<span id = 152></span>|31.5%|Medium|2020.07.23||
|174|[Dungeon Game](#174-dungeon-game)<span id = 174></span>|32.1%|Hard|||
|188|[Best Time to Buy and Sell Stock IV](#188-best-time-to-buy-and-sell-stock-iv)<span id = 188></span>|27.9%|Hard|2020.07.21||
|198|[House Robber](#198-house-robber)<span id = 198></span>|41.9%|Easy|2020.07.20|2020.07.20|
|213|[House Robber II](#213-house-robber-ii)<span id = 213></span>|36.4%|Medium|2020.07.20|2020.07.20|
|221|[Maximal Square](#221-maximal-square)<span id = 221></span>|37.6%|Medium|2020.07.20|2020.07.20|
|256|[Paint House](#256-paint-house)<span id = 256></span>|52.0%|Easy|||
|264|[Ugly Number II](#264-ugly-number-ii)<span id = 264></span>|41.9%|Medium|2020.07.20|2020.07.20|
|265|[Paint House II](#265-paint-house-ii)<span id = 265></span>|44.5%|Hard|||
|276|[Paint Fence](#276-paint-fence)<span id = 276></span>|38.1%|Easy|||
|279|[Perfect Squares](#279-perfect-squares)<span id = 279></span>|47.1%|Medium|2020.07.24|2020.07.22|
|300|[Longest Increasing Subsequence](#300-longest-increasing-subsequence)<span id = 300></span>|42.5%|Medium|2020.07.24|2020.07.22|
|303|[Range Sum Query - Immutable](#303-range-sum-query---immutable)<span id = 303></span>|44.2%|Easy|2020.07.24|2020.07.22|
|304|[Range Sum Query 2D - Immutable](#304-range-sum-query-2d---immutable)<span id = 304></span>|38.1%|Medium|2020.07.24||
|309|[Best Time to Buy and Sell Stock with Cooldown](#309-best-time-to-buy-and-sell-stock-with-cooldown)<span id = 309></span>|46.3%|Medium|2020.07.21||
|312|[Burst Balloons](#312-burst-balloons)<span id = 312></span>|51.4%|Hard|||
|321|[Create Maximum Number](#321-create-maximum-number)<span id = 321></span>|26.9%|Hard|||
|322|[Coin Change](#322-coin-change)<span id = 322></span>|35.1%|Medium|2020.07.23|2020.07.22|
|338|[Counting Bits](#338-counting-bits)<span id = 338></span>|69.3%|Medium|2020.07.20|2020.07.20|
|343|[Integer Break](#343-integer-break)<span id = 343></span>|50.1%|Medium|2020.07.22|2020.07.24|
|351|[Android Unlock Patterns](#351-android-unlock-patterns)<span id = 351></span>|48.2%|Medium|||
|354|[Russian Doll Envelopes](#354-russian-doll-envelopes)<span id = 354></span>|35.5%|Hard|||
|357|[Count Numbers with Unique Digits](#357-count-numbers-with-unique-digits)<span id = 357></span>|48.2%|Medium|2020.07.22|2020.07.22|
|361|[Bomb Enemy](#361-bomb-enemy)<span id = 361></span>|45.9%|Medium|||
|363|[Max Sum of Rectangle No Larger Than K](#363-max-sum-of-rectangle-no-larger-than-k)<span id = 363></span>|37.2%|Hard|||
|368|[Largest Divisible Subset](#368-largest-divisible-subset)<span id = 368></span>|38.1%|Medium|2020.07.29||
|375|[Guess Number Higher or Lower II](#375-guess-number-higher-or-lower-ii)<span id = 375></span>|40.2%|Medium|||
|376|[Wiggle Subsequence](#376-wiggle-subsequence)<span id = 376></span>|39.5%|Medium|||
|377|[Combination Sum IV](#377-combination-sum-iv)<span id = 377></span>|45.2%|Medium|||
|392|[Is Subsequence](#392-is-subsequence)<span id = 392></span>|49.1%|Easy|2020.07.20|2020.07.21|
|403|[Frog Jump](#403-frog-jump)<span id = 403></span>|39.5%|Hard|||
|410|[Split Array Largest Sum](#410-split-array-largest-sum)<span id = 410></span>|44.4%|Hard|||
|413|[Arithmetic Slices](#413-arithmetic-slices)<span id = 413></span>|57.8%|Medium|||
|416|[Partition Equal Subset Sum](#416-partition-equal-subset-sum)<span id = 416></span>|43.5%|Medium|||
|418|[Sentence Screen Fitting](#418-sentence-screen-fitting)<span id = 418></span>|32.6%|Medium|||
|446|[Arithmetic Slices II - Subsequence](#446-arithmetic-slices-ii---subsequence)<span id = 446></span>|32.6%|Hard|||
|464|[Can I Win](#464-can-i-win)<span id = 464></span>|28.8%|Medium|||
|466|[Count The Repetitions](#466-count-the-repetitions)<span id = 466></span>|28.2%|Hard|||
|467|[Unique Substrings in Wraparound String](#467-unique-substrings-in-wraparound-string)<span id = 467></span>|35.5%|Medium|||
|471|[Encode String with Shortest Length](#471-encode-string-with-shortest-length)<span id = 471></span>|47.0%|Hard|||
|472|[Concatenated Words](#472-concatenated-words)<span id = 472></span>|43.3%|Hard|||
|474|[Ones and Zeroes](#474-ones-and-zeroes)<span id = 474></span>|42.6%|Medium|2020.07.22||
|486|[Predict the Winner](#486-predict-the-winner)<span id = 486></span>|47.8%|Medium|||
|494|[Target Sum](#494-target-sum)<span id = 494></span>|46.4%|Medium|||
|514|[Freedom Trail](#514-freedom-trail)<span id = 514></span>|42.8%|Hard|||
|516|[Longest Palindromic Subsequence](#516-longest-palindromic-subsequence)<span id = 516></span>|52.8%|Medium|2020.07.27||
|517|[Super Washing Machines](#517-super-washing-machines)<span id = 517></span>|38.2%|Hard|||
|523|[Continuous Subarray Sum](#523-continuous-subarray-sum)<span id = 523></span>|24.6%|Medium|2020.07.29||
|546|[Remove Boxes](#546-remove-boxes)<span id = 546></span>|42.3%|Hard|||
|552|[Student Attendance Record II](#552-student-attendance-record-ii)<span id = 552></span>|36.5%|Hard|||
|568|[Maximum Vacation Days](#568-maximum-vacation-days)<span id = 568></span>|40.7%|Hard|||
|576|[Out of Boundary Paths](#576-out-of-boundary-paths)<span id = 576></span>|34.9%|Medium|||
|600|[Non-negative Integers without Consecutive Ones](#600-non-negative-integers-without-consecutive-ones)<span id = 600></span>|34.0%|Hard|||
|629|[K Inverse Pairs Array](#629-k-inverse-pairs-array)<span id = 629></span>|31.0%|Hard|||
|638|[Shopping Offers](#638-shopping-offers)<span id = 638></span>|51.3%|Medium|||
|639|[Decode Ways II](#639-decode-ways-ii)<span id = 639></span>|26.4%|Hard|||
|646|[Maximum Length of Pair Chain](#646-maximum-length-of-pair-chain)<span id = 646></span>|51.6%|Medium|2020.07.23||
|647|[Palindromic Substrings](#647-palindromic-substrings)<span id = 647></span>|60.4%|Medium|||
|650|[2 Keys Keyboard](#650-2-keys-keyboard)<span id = 650></span>|48.9%|Medium|2020.07.22||
|651|[4 Keys Keyboard](#651-4-keys-keyboard)<span id = 651></span>|52.4%|Medium|||
|656|[Coin Path](#656-coin-path)<span id = 656></span>|28.9%|Hard|||
|664|[Strange Printer](#664-strange-printer)<span id = 664></span>|40.0%|Hard|||
|673|[Number of Longest Increasing Subsequence](#673-number-of-longest-increasing-subsequence)<span id = 673></span>|35.6%|Medium|||
|688|[Knight Probability in Chessboard](#688-knight-probability-in-chessboard)<span id = 688></span>|48.6%|Medium|||
|689|[Maximum Sum of 3 Non-Overlapping Subarrays](#689-maximum-sum-of-3-non-overlapping-subarrays)<span id = 689></span>|46.0%|Hard|||
|691|[Stickers to Spell Word](#691-stickers-to-spell-word)<span id = 691></span>|42.6%|Hard|||
|698|[Partition to K Equal Sum Subsets](#698-partition-to-k-equal-sum-subsets)<span id = 698></span>|45.0%|Medium|||
|712|[Minimum ASCII Delete Sum for Two Strings](#712-minimum-ascii-delete-sum-for-two-strings)<span id = 712></span>|58.4%|Medium|2020.07.21||
|714|[Best Time to Buy and Sell Stock with Transaction Fee](#714-best-time-to-buy-and-sell-stock-with-transaction-fee)<span id = 714></span>|54.3%|Medium|2020.07.21||
|718|[Maximum Length of Repeated Subarray](#718-maximum-length-of-repeated-subarray)<span id = 718></span>|49.3%|Medium|2020.07.29||
|727|[Minimum Window Subsequence](#727-minimum-window-subsequence)<span id = 727></span>|41.5%|Hard|||
|730|[Count Different Palindromic Subsequences](#730-count-different-palindromic-subsequences)<span id = 730></span>|41.6%|Hard|||
|740|[Delete and Earn](#740-delete-and-earn)<span id = 740></span>|48.5%|Medium|||
|741|[Cherry Pickup](#741-cherry-pickup)<span id = 741></span>|33.9%|Hard|||
|746|[Min Cost Climbing Stairs](#746-min-cost-climbing-stairs)<span id = 746></span>|50.2%|Easy|2020.07.20||
|750|[Number Of Corner Rectangles](#750-number-of-corner-rectangles)<span id = 750></span>|66.4%|Medium|||
|764|[Largest Plus Sign](#764-largest-plus-sign)<span id = 764></span>|46.0%|Medium|||
|787|[Cheapest Flights Within K Stops](#787-cheapest-flights-within-k-stops)<span id = 787></span>|39.3%|Medium|||
|790|[Domino and Tromino Tiling](#790-domino-and-tromino-tiling)<span id = 790></span>|39.0%|Medium|||
|801|[Minimum Swaps To Make Sequences Increasing](#801-minimum-swaps-to-make-sequences-increasing)<span id = 801></span>|38.8%|Medium|||
|808|[Soup Servings](#808-soup-servings)<span id = 808></span>|39.7%|Medium|||
|813|[Largest Sum of Averages](#813-largest-sum-of-averages)<span id = 813></span>|49.7%|Medium|2020.07.22||
|818|[Race Car](#818-race-car)<span id = 818></span>|38.7%|Hard|||
|837|[New 21 Game](#837-new-21-game)<span id = 837></span>|34.5%|Medium|||
|838|[Push Dominoes](#838-push-dominoes)<span id = 838></span>|48.2%|Medium|2020.07.24||
|847|[Shortest Path Visiting All Nodes](#847-shortest-path-visiting-all-nodes)<span id = 847></span>|51.7%|Hard|||
|871|[Minimum Number of Refueling Stops](#871-minimum-number-of-refueling-stops)<span id = 871></span>|31.2%|Hard|||
|873|[Length of Longest Fibonacci Subsequence](#873-length-of-longest-fibonacci-subsequence)<span id = 873></span>|47.6%|Medium|||
|877|[Stone Game](#877-stone-game)<span id = 877></span>|64.5%|Medium|2020.07.20|2020.07.22|
|879|[Profitable Schemes](#879-profitable-schemes)<span id = 879></span>|39.6%|Hard|||
|887|[Super Egg Drop](#887-super-egg-drop)<span id = 887></span>|27.1%|Hard|||
|898|[Bitwise ORs of Subarrays](#898-bitwise-ors-of-subarrays)<span id = 898></span>|35.0%|Medium|||
|902|[Numbers At Most N Given Digit Set](#902-numbers-at-most-n-given-digit-set)<span id = 902></span>|31.4%|Hard|||
|903|[Valid Permutations for DI Sequence](#903-valid-permutations-for-di-sequence)<span id = 903></span>|49.5%|Hard|||
|920|[Number of Music Playlists](#920-number-of-music-playlists)<span id = 920></span>|46.4%|Hard|||
|931|[Minimum Falling Path Sum](#931-minimum-falling-path-sum)<span id = 931></span>|62.2%|Medium|2020.07.16|2020.07.20|
|935|[Knight Dialer](#935-knight-dialer)<span id = 935></span>|44.9%|Medium|||
|940|[Distinct Subsequences II](#940-distinct-subsequences-ii)<span id = 940></span>|41.5%|Hard|||
|943|[Find the Shortest Superstring](#943-find-the-shortest-superstring)<span id = 943></span>|42.7%|Hard|||
|956|[Tallest Billboard](#956-tallest-billboard)<span id = 956></span>|39.7%|Hard|||
|960|[Delete Columns to Make Sorted III](#960-delete-columns-to-make-sorted-iii)<span id = 960></span>|53.6%|Hard|||
|964|[Least Operators to Express Number](#964-least-operators-to-express-number)<span id = 964></span>|43.7%|Hard|||
|967|[Numbers With Same Consecutive Differences](#967-numbers-with-same-consecutive-differences)<span id = 967></span>|39.2%|Medium|||
|968|[Binary Tree Cameras](#968-binary-tree-cameras)<span id = 968></span>|37.2%|Hard|||
|975|[Odd Even Jump](#975-odd-even-jump)<span id = 975></span>|42.5%|Hard|||
|978|[Longest Turbulent Subarray](#978-longest-turbulent-subarray)<span id = 978></span>|46.5%|Medium|||
|982|[Triples with Bitwise AND Equal To Zero](#982-triples-with-bitwise-and-equal-to-zero)<span id = 982></span>|55.6%|Hard|||
|983|[Minimum Cost For Tickets](#983-minimum-cost-for-tickets)<span id = 983></span>|60.1%|Medium|2020.07.24||
|1000|[Minimum Cost to Merge Stones](#1000-minimum-cost-to-merge-stones)<span id = 1000></span>|39.5%|Hard|||
|1012|[Numbers With Repeated Digits](#1012-numbers-with-repeated-digits)<span id = 1012></span>|37.4%|Hard|||
|1024|[Video Stitching](#1024-video-stitching)<span id = 1024></span>|49.1%|Medium|||
|1025|[Divisor Game](#1025-divisor-game)<span id = 1025></span>|66.2%|Easy|2020.07.24||
|1027|[Longest Arithmetic Sequence](#1027-longest-arithmetic-sequence)<span id = 1027></span>|53.5%|Medium|||
|1039|[Minimum Score Triangulation of Polygon](#1039-minimum-score-triangulation-of-polygon)<span id = 1039></span>|48.7%|Medium|||
|1048|[Longest String Chain](#1048-longest-string-chain)<span id = 1048></span>|54.5%|Medium|||
|1049|[Last Stone Weight II](#1049-last-stone-weight-ii)<span id = 1049></span>|44.0%|Medium|||
|1055|[Shortest Way to Form String](#1055-shortest-way-to-form-string)<span id = 1055></span>|57.0%|Medium|||
|1058|[Minimize Rounding Error to Meet Target](#1058-minimize-rounding-error-to-meet-target)<span id = 1058></span>|41.8%|Medium|||
|1066|[Campus Bikes II](#1066-campus-bikes-ii)<span id = 1066></span>|54.3%|Medium|||
|1067|[Digit Count in Range](#1067-digit-count-in-range)<span id = 1067></span>|39.8%|Hard|||
|1074|[Number of Submatrices That Sum to Target](#1074-number-of-submatrices-that-sum-to-target)<span id = 1074></span>|59.0%|Hard|||
|1092|[Shortest Common Supersequence](#1092-shortest-common-supersequence)<span id = 1092></span>|51.1%|Hard|2020.07.27||
|1105|[Filling Bookcase Shelves](#1105-filling-bookcase-shelves)<span id = 1105></span>|58.2%|Medium|||
|1125|[Smallest Sufficient Team](#1125-smallest-sufficient-team)<span id = 1125></span>|46.4%|Hard|||
|1130|[Minimum Cost Tree From Leaf Values](#1130-minimum-cost-tree-from-leaf-values)<span id = 1130></span>|65.9%|Medium|||
|1136|[Parallel Courses](#1136-parallel-courses)<span id = 1136></span>|61.0%|Hard|||
|1139|[Largest 1-Bordered Square](#1139-largest-1-bordered-square)<span id = 1139></span>|47.2%|Medium|||
|1140|[Stone Game II](#1140-stone-game-ii)<span id = 1140></span>|62.8%|Medium|||
|1143|[Longest Common Subsequence](#1143-longest-common-subsequence)<span id = 1143></span>|58.4%|Medium|2020.07.27||
|1147|[Longest Chunked Palindrome Decomposition](#1147-longest-chunked-palindrome-decomposition)<span id = 1147></span>|58.5%|Hard|||
|1155|[Number of Dice Rolls With Target Sum](#1155-number-of-dice-rolls-with-target-sum)<span id = 1155></span>|49.2%|Medium|||
|1186|[Maximum Subarray Sum with One Deletion](#1186-maximum-subarray-sum-with-one-deletion)<span id = 1186></span>|37.2%|Medium|||
|1187|[Make Array Strictly Increasing](#1187-make-array-strictly-increasing)<span id = 1187></span>|41.6%|Hard|||
|1191|[K-Concatenation Maximum Sum](#1191-k-concatenation-maximum-sum)<span id = 1191></span>|25.9%|Medium|||
|1199|[Minimum Time to Build Blocks](#1199-minimum-time-to-build-blocks)<span id = 1199></span>|37.1%|Hard|||
|1216|[Valid Palindrome III](#1216-valid-palindrome-iii)<span id = 1216></span>|47.7%|Hard|||
|1218|[Longest Arithmetic Subsequence of Given Difference](#1218-longest-arithmetic-subsequence-of-given-difference)<span id = 1218></span>|44.0%|Medium|||
|1220|[Count Vowels Permutation](#1220-count-vowels-permutation)<span id = 1220></span>|53.6%|Hard|||
|1223|[Dice Roll Simulation](#1223-dice-roll-simulation)<span id = 1223></span>|45.5%|Medium|||
|1227|[Airplane Seat Assignment Probability](#1227-airplane-seat-assignment-probability)<span id = 1227></span>|60.5%|Medium|||
|1230|[Toss Strange Coins](#1230-toss-strange-coins)<span id = 1230></span>|48.3%|Medium|||
|1235|[Maximum Profit in Job Scheduling](#1235-maximum-profit-in-job-scheduling)<span id = 1235></span>|44.3%|Hard|||
|1240|[Tiling a Rectangle with the Fewest Squares](#1240-tiling-a-rectangle-with-the-fewest-squares)<span id = 1240></span>|49.4%|Hard|||
|1246|[Palindrome Removal](#1246-palindrome-removal)<span id = 1246></span>|46.0%|Hard|||
|1259|[Handshakes That Don't Cross](#1259-handshakes-that-don't-cross)<span id = 1259></span>|53.3%|Hard|||
|1262|[Greatest Sum Divisible by Three](#1262-greatest-sum-divisible-by-three)<span id = 1262></span>|47.4%|Medium|||
|1269|[Number of Ways to Stay in the Same Place After Some Steps](#1269-number-of-ways-to-stay-in-the-same-place-after-some-steps)<span id = 1269></span>|43.0%|Hard|||
|1273|[Delete Tree Nodes](#1273-delete-tree-nodes)<span id = 1273></span>|63.4%|Medium|||
|1277|[Count Square Submatrices with All Ones](#1277-count-square-submatrices-with-all-ones)<span id = 1277></span>|72.9%|Medium|2020.07.20|2020.07.22|
|1278|[Palindrome Partitioning III](#1278-palindrome-partitioning-iii)<span id = 1278></span>|59.7%|Hard|||
|1289|[Minimum Falling Path Sum II](#1289-minimum-falling-path-sum-ii)<span id = 1289></span>|60.7%|Hard|2020.07.16||
|1301|[Number of Paths with Max Score](#1301-number-of-paths-with-max-score)<span id = 1301></span>|37.1%|Hard|||
|1312|[Minimum Insertion Steps to Make a String Palindrome](#1312-minimum-insertion-steps-to-make-a-string-palindrome)<span id = 1312></span>|57.7%|Hard|||
|1314|[Matrix Block Sum](#1314-matrix-block-sum)<span id = 1314></span>|73.8%|Medium|||
|1320|[Minimum Distance to Type a Word Using Two Fingers](#1320-minimum-distance-to-type-a-word-using-two-fingers)<span id = 1320></span>|62.1%|Hard|||
|1326|[Minimum Number of Taps to Open to Water a Garden](#1326-minimum-number-of-taps-to-open-to-water-a-garden)<span id = 1326></span>|43.0%|Hard|||
|1335|[Minimum Difficulty of a Job Schedule](#1335-minimum-difficulty-of-a-job-schedule)<span id = 1335></span>|57.1%|Hard|||
|1339|[Maximum Product of Splitted Binary Tree](#1339-maximum-product-of-splitted-binary-tree)<span id = 1339></span>|37.1%|Medium|||
|1340|[Jump Game V](#1340-jump-game-v)<span id = 1340></span>|57.3%|Hard|||
|1349|[Maximum Students Taking Exam](#1349-maximum-students-taking-exam)<span id = 1349></span>|40.9%|Hard|||
|1359|[Count All Valid Pickup and Delivery Options](#1359-count-all-valid-pickup-and-delivery-options)<span id = 1359></span>|57.6%|Hard|||
|1363|[Largest Multiple of Three](#1363-largest-multiple-of-three)<span id = 1363></span>|33.4%|Hard|||
|1367|[Linked List in Binary Tree](#1367-linked-list-in-binary-tree)<span id = 1367></span>|39.5%|Medium|||
|1372|[Longest ZigZag Path in a Binary Tree](#1372-longest-zigzag-path-in-a-binary-tree)<span id = 1372></span>|53.6%|Medium|||
|1373|[Maximum Sum BST in Binary Tree](#1373-maximum-sum-bst-in-binary-tree)<span id = 1373></span>|41.0%|Hard|||
|1388|[Pizza With 3n Slices](#1388-pizza-with-3n-slices)<span id = 1388></span>|44.3%|Hard|||
|1397|[Find All Good Strings](#1397-find-all-good-strings)<span id = 1397></span>|37.1%|Hard|||
|1402|[Reducing Dishes](#1402-reducing-dishes)<span id = 1402></span>|72.9%|Hard|||
|1405|[Longest Happy String](#1405-longest-happy-string)<span id = 1405></span>|48.0%|Medium|||
|1406|[Stone Game III](#1406-stone-game-iii)<span id = 1406></span>|55.8%|Hard|||
|1411|[Number of Ways to Paint N × 3 Grid](#1411-number-of-ways-to-paint-n-×-3-grid)<span id = 1411></span>|61.4%|Hard|||
|1416|[Restore The Array](#1416-restore-the-array)<span id = 1416></span>|36.3%|Hard|||
|1420|[Build Array Where You Can Find The Maximum Exactly K Comparisons](#1420-build-array-where-you-can-find-the-maximum-exactly-k-comparisons)<span id = 1420></span>|65.4%|Hard|||
|1423|[Maximum Points You Can Obtain from Cards](#1423-maximum-points-you-can-obtain-from-cards)<span id = 1423></span>|41.4%|Medium|||
|1425|[Constrained Subsequence Sum](#1425-constrained-subsequence-sum)<span id = 1425></span>|43.9%|Hard|||
|1434|[Number of Ways to Wear Different Hats to Each Other](#1434-number-of-ways-to-wear-different-hats-to-each-other)<span id = 1434></span>|37.8%|Hard|||
|1444|[Number of Ways of Cutting a Pizza](#1444-number-of-ways-of-cutting-a-pizza)<span id = 1444></span>|52.4%|Hard|||
|1449|[Form Largest Integer With Digits That Add up to Target](#1449-form-largest-integer-with-digits-that-add-up-to-target)<span id = 1449></span>|41.2%|Hard|||
|1458|[Max Dot Product of Two Subsequences](#1458-max-dot-product-of-two-subsequences)<span id = 1458></span>|41.5%|Hard|||
|1463|[Cherry Pickup II](#1463-cherry-pickup-ii)<span id = 1463></span>|64.6%|Hard|||
|1473|[Paint House III](#1473-paint-house-iii)<span id = 1473></span>|47.7%|Hard|||
|1477|[Find Two Non-overlapping Sub-arrays Each With Target Sum](#1477-find-two-non-overlapping-sub-arrays-each-with-target-sum)<span id = 1477></span>|28.3%|Medium|||
|1478|[Allocate Mailboxes](#1478-allocate-mailboxes)<span id = 1478></span>|54.4%|Hard|||
|1483|[Kth Ancestor of a Tree Node](#1483-kth-ancestor-of-a-tree-node)<span id = 1483></span>|26.9%|Hard|||
|1504|[Count Submatrices With All Ones](#1504-count-submatrices-with-all-ones)<span id = 1504></span>|60.9%|Medium|2020.07.27||
|1510|[Stone Game IV](#1510-stone-game-iv)<span id = 1510></span>|47.5%|Hard|||



## 5. Longest Palindromic Substring

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：** 遍历一遍字符串, 由中间向两边做回文判断, 注意奇数回文和偶数回文的不同

```c
int expandFromCenter(char *s, int left, int right, int N){
    while(left>=0&&right<N&&s[left]==s[right]){
            left--;
            right++;
        }
    return right-left-1;
}

char *longestPalindrome(char *s) {
    int N = strlen(s);
    if (!N) return "";
    int start_p = 0;
    int end_p = 0;

    for (int i = 0; i < N; i++) {
        int odd_len = expandFromCenter(s, i, i, N);
        int even_len = expandFromCenter(s, i, i + 1, N);
        if (odd_len > end_p - start_p) {
            start_p = i - odd_len / 2;
            end_p = i + odd_len / 2;
        }
        if (even_len > end_p - start_p) {
            start_p = i - even_len / 2 + 1;
            end_p = i + even_len / 2;
        }
    }
    *(s + end_p + 1) = '\0';
    return s + start_p;
}
```

[返回目录](#5)

## 10. Regular Expression Matching

Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.

> '.' Matches any single character.
>
> '*' Matches zero or more of the preceding element.
>
> The matching should cover the entire input string (not partial).

**Note:**
 - s could be empty and contains only lowercase letters a-z.
 - p could be empty and contains only lowercase letters a-z, and characters like . or *.

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

> '.' 匹配任意单个字符
>
> '*' 匹配零个或多个前面的那一个元素
>
> 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

**说明:**
 - s 可能为空，且只包含从 a-z 的小写字母。
 - p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。


**Example**

```
Example 1:
Input:
s = "aab"
p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches "aab".

Example 2:
Input:
s = "mississippi"
p = "mis*is*p*."
Output: false
```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.length(), n = p.length();

        bool dp[n+1], pre, cur;
        dp[0] = true;
        for (int j = 0; j < n; j++) {
            dp[j+1] = p[j] == '*' ? dp[j-1] : false;
        }

        for (int i = 0; i < m; i++) {
            pre = dp[0];
            dp[0] = false;
            for (int j = 0; j < n; j++) {
                cur = dp[j+1];
                if (p[j] == '*') {
                    dp[j+1] = dp[j-1]
                           || dp[j+1] && (p[j-1] == s[i] || p[j-1] == '.');
                } else {
                    dp[j+1] = pre && (p[j] == s[i] || p[j] == '.');
                }
                pre = cur;
            }
        }
        return dp[n];
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#10)

## 32. Longest Valid Parentheses

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#32)

## 44. Wildcard Matching

给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。

> '?' 可以匹配任何单个字符。
>
> '*' 可以匹配任意字符串（包括空字符串）。
>
> 两个字符串完全匹配才算匹配成功。

**说明:**
 - s 可能为空，且只包含从 a-z 的小写字母。
 - p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。

Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.

> '?' Matches any single character.
>
> '*' Matches any sequence of characters (including the empty sequence).
>
> The matching should cover the entire input string (not partial).

**Note:**
 - s could be empty and contains only lowercase letters a-z.
 - p could be empty and contains only lowercase letters a-z, and characters like ? or *.

**Example**

```
Example 1:
Input:
s = "cb"
p = "?a"
Output: false
Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.

Example 2:
Input:
s = "adceb"
p = "*a*b"
Output: true
Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring "dce".

Example 3:
Input:
s = "acdcb"
p = "a*c?b"
Output: false
```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.length(), n = p.length();

        bool dp[n+1], pre, cur;
        dp[0] = true;
        for (int j = 0; j < n; j++) {
            dp[j+1] = p[j] == '*' ? dp[j] : false;
        }

        for (int i = 0; i < m; i++) {
            pre = dp[0];
            dp[0] = false;
            for (int j = 0; j < n; j++) {
                cur = dp[j+1];
                if (p[j] == '*') {
                    dp[j+1] = dp[j] || dp[j+1];
                } else {
                    dp[j+1] = pre && (p[j] == s[i] || p[j] == '?');
                }
                pre = cur;
            }
        }
        return dp[n];
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#44)

## 53. Maximum Subarray

Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**Example**

```
Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int best = INT_MIN, prev = 0;
        for (auto& num: nums) {
            prev = max(num, prev + num);
            best = max(best, prev);
        }
        return best;
    }
};
```

### C Solution
**分析：**

```c
int maxSubArray(int* nums, int numsSize){
    int res = *nums;
    int cur_max = *nums;
    for (int i = 1; i < numsSize; ++i) {
        res += nums[i];
        if (res < nums[i]) res = nums[i];
        cur_max = cur_max > res ? cur_max : res;
    }
    return cur_max;
}
```

[返回目录](#53)

## 62. Unique Paths

A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?

机器人位于m x n网格的左上角（在下图中标记为“开始”）。

机器人只能在任何时间点上下移动。 机器人试图到达网格的右下角（在下图中标记为“完成”）。

有多少种可能的独特路径？

**Example**

```
Example 1:
Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right

Example 2:
Input: m = 7, n = 3
Output: 28
```

---

### Cpp Solution
**分析：** 比较简单的动态规划问题，每个格只与上方和左方的状态有关，所以可以状态压缩到一维。

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n, 1);
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[j] += dp[j-1];
            }
        }
        return dp[n-1];
    }
};
```

### C Solution
**分析：**二维的dp (手动捂脸)

```c
int
uniquePaths(int m, int n) {
    int dp[m][n];
    for (int i = 0; i < m; ++i)
        dp[i][0] = 1;
    for (int j = 0; j < n; ++j)
        dp[0][j] = 1;

    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m-1][n-1];
}
```

[返回目录](#62)

## 63. Unique Paths II

A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

Now consider if some obstacles are added to the grids. How many unique paths would there be?

An obstacle and empty space is marked as 1 and 0 respectively in the grid.

Note: m and n will be at most 100.

机器人位于m x n网格的左上角（在下图中标记为“开始”）。

机器人只能在任何时间点上下移动。 机器人试图到达网格的右下角（在下图中标记为“完成”）。

现在考虑是否在网格中添加了一些障碍。 会有多少条独特的路径？

网格中的障碍物和空白区域分别标记为1和0。

注意：m和n最多为100。

**Example**

```
Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
Explanation:
There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right
```

---

### Cpp Solution
**分析：** 作为上一题的followup，这道题也比较简单，只需要考虑到有障碍的情况就可以了。唯一需要注意题目返回值如果不为int，那么vector也需要跟着变。

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& oG) {
        int m = oG.size(), n = oG[0].size();
        vector<int> dp(n);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int left = j ? dp[j-1] : 0;
                int up = i ? dp[j] : (j ? 0 : 1);
                dp[j] = oG[i][j] == 0 ? left + up : 0;
            }
        }
        return dp[n-1];
    }
};
```

### C Solution
**分析：**

```c
int uniquePathsWithObstacles(int **obstacleGrid, int obstacleGridSize, int *obstacleGridColSize) {
    if (obstacleGrid[0][0]) return 0;
    unsigned int dp[obstacleGridSize][obstacleGridColSize[0]];
    dp[0][0] = 1;
    for (int i = 1; i < obstacleGridSize; ++i)
        dp[i][0] = obstacleGrid[i][0] ? 0 : dp[i - 1][0];

    for (int i = 1; i < obstacleGridColSize[0]; ++i)
        dp[0][i] = obstacleGrid[0][i] ? 0 : dp[0][i - 1];

    for (int i = 1; i < obstacleGridSize; ++i)
        for (int j = 1; j < obstacleGridColSize[0]; ++j)
            dp[i][j] = obstacleGrid[i][j] ? 0 : dp[i - 1][j] + dp[i][j - 1];

    return dp[obstacleGridSize - 1][obstacleGridColSize[0] - 1];
}
```

[返回目录](#63)

## 64. Minimum Path Sum

Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

给定一个m×n的网格，其中填充了非负数，请找到一条从左上到右下的路径，该路径将沿其路径的所有数字的总和最小化。 

注意：您只能在任何时间点向下或向右移动。

**Example**

```
Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
```

---

### Cpp Solution
**分析：** 同样是上一题的followup，注意的点是数据溢出和边界条件处理。

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> dp(n, 0);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int left = j ? dp[j-1] : INT_MAX;
                int up = i ? dp[j] : (j ? 0 : INT_MAX);
                dp[j] = grid[i][j] + min(left, up);
            }
        }
        return dp[n-1];
    }
};
```

### C Solution
**分析：**重用矩阵, 边界问题先处理掉

```c
int minPathSum(int** grid, int gridSize, int* gridColSize){
    for (int i = 1; i < gridSize; ++i)
        grid[i][0] += grid[i-1][0];
    for (int k = 1; k < gridColSize[0]; ++k)
        grid[0][k] += grid[0][k-1];

    for (int i = 1; i < gridSize; ++i) {
        for (int j = 1; j < gridColSize[i]; ++j) {
            grid[i][j] += (grid[i-1][j] < grid[i][j-1] ? grid[i-1][j] : grid[i][j-1]);
        }
    }

    return grid[gridSize-1][(*gridColSize)-1];
}
```

[返回目录](#64)

## 70. Climbing Stairs

You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

您正在爬楼梯。 它需要n步才能到达顶部。

每次您可以爬1或2步。 您可以通过几种不同的方式登顶？

**Example**

```
Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
```

---

### Cpp Solution
**分析：** 斐波那契数列问题，经典简单动态规划

```cpp
class Solution {
public:
    int climbStairs(int n) {
        int a = 0, b = 1;
        for (int i = 0; i < n; i++) {
            a += b;
            swap(a, b);
        }
        return b;
    }
};
```

### C Solution
**分析：**

```c
int climbStairs(int n){
    int dp[n+1];
    dp[0] = dp[1] = 1;
    for (int i = 2; i <= n; ++i)
        dp[i] = dp[i-1] + dp[i-2];

    return dp[n];
}
```

[返回目录](#70)

## 72. Edit Distance

Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.

You have the following 3 operations permitted on a word:

1. Insert a character
2. Delete a character
3. Replace a character

给定两个单词word1和word2，找到将word1转换为word2所需的最少操作数。

您可以对一个单词进行以下3个操作

1. 插入一个字符
2. 删除一个字符
3. 替换一个字符

**Example**

```
Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
```

---

### Cpp Solution
**分析：** 也是很经典的一道动态规划hard的题目，可以状态压缩到一维。

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.length(), n = word2.length();

        vector<int> dp(n+1, 0);
        for (int i = 0; i < n + 1; i++) dp[i] = i;

        int prev, cur;
        for (int i = 0; i < m; i++) {
            prev = dp[0]++;

            for (int j = 0; j < n; j++) {
                cur = dp[j+1];

                if (word1[i] == word2[j]) {
                    dp[j+1] = prev;
                } else {
                    dp[j+1] = 1 + min(prev, min(dp[j], dp[j+1]));
                }

                prev = cur;
            }
        }
        return dp[n];
    }
};
```

### C Solution
**分析：**

```c
int min(int a, int b, int c) {
    int res = a;
    res = res < b ? res : b;
    res = res < c ? res : c;

    return res;
}

int minDistance(char *word1, char *word2) {
    size_t word1_len = strlen(word1);
    size_t word2_len = strlen(word2);

    int dp[word1_len+1][word2_len+1];

    for (int i = 0; i <= word1_len; ++i) {
        dp[i][0] = i;
    }
    for (int j = 0; j <= word2_len; ++j) {
        dp[0][j] = j;
    }

    for (int i = 1; i <= word1_len; ++i) {
        for (int j = 1; j <= word2_len; ++j) {
            if (word1[i-1] == word2[j-1]) {
                dp[i][j] = dp[i-1][j-1];
            } else {
                dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) + 1;
            }
        }
    }
    return dp[word1_len][word2_len];
}
```

[返回目录](#72)

## 85. Maximal Rectangle

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#85)

## 87. Scramble String

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#87)

## 91. Decode Ways

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#91)

## 95. Unique Binary Search Trees II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#95)

## 96. Unique Binary Search Trees

Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n?

给定n，多少个结构唯一的BST（二进制搜索树）存储值1 ... n？

**Example**

```
Input: 3
Output: 5
Explanation:
Given n = 3, there are a total of 5 unique BST's:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                dp[i] += dp[j] * dp[i-j-1];
            }
        }
        return dp[n];
    }
};
```

### C Solution
**分析：**

```c
int numTrees(int n) {
    int dp[n + 1];
    memset(dp, 0, sizeof(dp));
    dp[0] = dp[1] = 1;

    for (int i = 2; i <= n; ++i) {
        for (int j = 0; j < i; ++j) {
            dp[i] += dp[j] * dp[i-j-1];
        }
    }
    return dp[n];
}
```

[返回目录](#96)

## 97. Interleaving String

Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.

给定s1，s2，s3，找出s3是否由s1和s2的交错形成。

**Example**

```
Example 1:
Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
Output: true

Example 2:
Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
Output: false
```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        int m = s1.length(), n = s2.length();
        if (m + n != s3.length()) return false;

        bool dp[n+1];

        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                if (i == 0 && j == 0) {
                    dp[j] = true;
                } else if (i == 0) {
                    dp[j] = dp[j-1] && s2[j-1] == s3[j-1];
                } else if (j == 0) {
                    dp[j] = dp[j] && s1[i-1] == s3[i-1];
                } else {
                    dp[j] = dp[j-1] && s2[j-1] == s3[i+j-1] \
                         || dp[j] && s1[i-1] == s3[i+j-1];
                }
            }
        }
        return dp[n];
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#97)

## 115. Distinct Subsequences

Given a string S and a string T, count the number of distinct subsequences of S which equals T.

A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not).

It's guaranteed the answer fits on a 32-bit signed integer.

在给定字符串S和字符串T的情况下，计算S等于T的不同子序列的数量。

字符串的子序列是一个新字符串，它是通过删除一些字符（可以是无字符）而不受干扰的，由原始字符串形成的 其余字符的相对位置。 （即，“ ACE”是“ ABCDE”的子序列，而“ AEC”不是）。

可以保证答案适合32位有符号整数。（它在放屁= =）

**Example**

```
Input: S = "rabbbit", T = "rabbit"
Output: 3
Explanation:
As shown below, there are 3 ways you can generate "rabbit" from S.
(The caret symbol ^ means the chosen letters)

rabbbit
^^^^ ^^
rabbbit
^^ ^^^^
rabbbit
^^^ ^^^
```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int numDistinct(string s, string t) {
        int m = s.length(), n = t.length();
        long dp[n+1];
        memset(dp, 0, sizeof(dp));
        dp[0] = 1;

        for (int i = 0; i < m; i++) {
            for (int j = n; j > 0; j--) {
                if (s[i] == t[j-1]) {
                    dp[j] += dp[j-1];
                }
            }
        }
        return dp[n];
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#115)

## 120. Triangle

Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.】

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。

**Example**

```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]

The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).
```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        vector<int> dp(triangle[n-1]);

        for (int i = n - 2; i >= 0; i--) {
            for (int j = 0; j <= i; j++) {
                dp[j] = triangle[i][j] + min(dp[j], dp[j+1]);
            }
        }
        return dp[0];
    }
};
```

### C Solution
**分析：**

```c
int minimumTotal(int **triangle, int triangleSize, int *triangleColSize) {
    int min_path[triangleSize];

    int x, y;
    min_path[0] = triangle[0][0];
    for (int i = 1; i < triangleSize; ++i) {
        // 填最右边
        min_path[i] = triangle[i][i] + min_path[i - 1];

        // 中间
        for (int j = i - 1; j > 0; --j) {
            x = min_path[j - 1];
            y = min_path[j];
            min_path[j] = triangle[i][j] + (x < y ? x : y);
        }
        // 填最左边
        min_path[0] += triangle[i][0];
    }

    int res = INT32_MAX;
    for (int i = 0; i < triangleSize; ++i) {
        res = res < min_path[i] ? res : min_path[i];
    }
    return res;
}
```

[返回目录](#120)

## 121. Best Time to Buy and Sell Stock

Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

假设您有一个数组，第i个元素是第i天给定股票的价格。

如果只允许您最多完成一笔交易（即买入和卖出一股股票），请设计一种算法以找到最大的利润。

**Example**

```
Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int min_p = INT_MAX, res = 0;
        for (auto& p: prices) {
            min_p = min(min_p, p);
            res = max(res, p - min_p);
        }
        return res;
    }
};
```

### C Solution
**分析：**

```c
int maxProfit(int* prices, int pricesSize){
    int benefit = 0;
    int buy_prices = INT32_MAX;
    int tmp;
    for (int i = 0; i < pricesSize; ++i) {
        benefit = benefit > (tmp = prices[i] - buy_prices) ? benefit : tmp;
        buy_prices = prices[i] < buy_prices ? prices[i] : buy_prices;
    }

    return benefit;
}
```

[返回目录](#121)

## 123. Best Time to Buy and Sell Stock III

Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most two transactions.

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**Example**

```
Example 1:
Input: [3,3,5,0,0,3,1,4]
Output: 6
Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.
             
Example 2:
Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
             
Example 3:
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int has1 = INT_MIN, has2 = INT_MIN;
        int sld1 = 0, sld2 = 0;

        for (auto& p: prices) {
            sld2 = max(sld2, has2 + p);
            has2 = max(has2, sld1 - p);
            sld1 = max(sld1, has1 + p);
            has1 = max(has1, -p);
        }
        return sld2;
    }
};
```

### C Solution
**分析：**

```c
int maxProfit(int *prices, int pricesSize) {
    if (!(pricesSize) || pricesSize == 1) return 0;

    int cur_min = *prices;
    int most_benefit1 = 0;
    int max1[pricesSize];

    for (int i = 0; i < pricesSize; ++i) {
        if (prices[i] > cur_min)
            most_benefit1 = most_benefit1 > prices[i] - cur_min ? most_benefit1 : prices[i] - cur_min;
        else
            cur_min = prices[i];

        max1[i] = most_benefit1;
    }

    int cur_max = prices[pricesSize - 1];
    int most_benefit2 = 0;
    int max2[pricesSize];

    for (int i = pricesSize - 1; i >= 0; --i) {
        if (prices[i] < cur_max)
            most_benefit2 = most_benefit2 > cur_max - prices[i] ? most_benefit2 : cur_max - prices[i];
        else
            cur_max = prices[i];
      
        max2[i] = most_benefit2;
    }

    int res = INT32_MIN;
    for (int i = 0; i < pricesSize; ++i)
        res = res > (max1[i] + max2[i]) ? res : (max1[i] + max2[i]);
    return res;
}
```

[返回目录](#123)

## 132. Palindrome Partitioning II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#132)

## 139. Word Break

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        set<string> wordSet(wordDict.begin(), wordDict.end());

        int n = s.length();
        vector<bool> dp(n+1, false);
        dp[0] = true;

        for (int i = 1; i <= n; i++) {
            for (int j = i - 1; j >= 0; j--) {
                if (dp[j] && wordSet.find(s.substr(j, i - j)) != wordSet.end()) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[n];
    }
};
```

### C Solution
**分析：**

```c
bool wordBreak(char *s, char **wordDict, int wordDictSize) {
    size_t s_len = strlen(s);
    bool dp[s_len + 1];
    dp[0] = 1;
    for (int i = 1; i <= s_len; ++i) {
        dp[i] = 0;
    }

    bool in(const char *, int from, int to, char **, int size);
    for (int i = 0; i < s_len; ++i) {
        for (int j = i + 1; j < s_len + 1; ++j) {
            if (dp[i] && in(s, i, j, wordDict, wordDictSize)) dp[j] = 1;
        }
    }
    return dp[s_len];
}

bool in(const char *s, int from, int to, char **word_dict, int size) {
    char *cur_word;
    for (int i = 0; i < size; ++i) {
        cur_word = word_dict[i];

        int tmp = 0;
        int j;
        for (j = from; j < to; ++j) {
            if (s[j] != cur_word[tmp++]) break;
        }
        if (j == to && cur_word[tmp] == '\0') return true;
    }
    return false;
}
```

[返回目录](#139)

## 140. Word Break II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    vector<string> wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());

        unordered_map<int, vector<string>> memo {{s.size(), {""}}};

        function<vector<string>(int)> sentences = [&](int i) {
            if (!memo.count(i))
                for (int j=i+1; j<=s.size(); j++)
                    if (wordSet.count(s.substr(i, j-i)))
                        for (string tail : sentences(j))
                            memo[i].push_back(s.substr(i, j-i) + (tail=="" ? "" : ' ' + tail));
            return memo[i];
        };
        return sentences(0);
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#140)

## 152. Maximum Product Subarray

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        if (nums.empty()) return 0;

        int res = nums[0], min_n = nums[0], max_n = nums[0];

        for (int i = 1; i < nums.size(); i++) {
            int min_tmp = min_n;
            min_n = min({nums[i], nums[i] * min_n, nums[i] * max_n});
            max_n = max({nums[i], nums[i] * min_tmp, nums[i] * max_n});
            res = max({res, max_n});
        }
        return res;
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#152)

## 174. Dungeon Game

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#174)

## 188. Best Time to Buy and Sell Stock IV

**Example**

```

```

---

### Cpp Solution
**分析：** 题目比较简单，但是边界条件比较恶心。需要注意 k 特别大的时候的判断，可能申请空间不够。

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int len = prices.size();
        if (!k || !len) return 0;

        if (k > len / 2) { // simple case
            int ans = 0;
            for (int i=1; i<len; i++){
                ans += max(prices[i] - prices[i-1], 0);
            }
            return ans;
        }

        vector<int> has(k+1, INT_MIN);
        vector<int> sld(k+1, 0);

        for (auto& p: prices) {
            for (int i = k; i > 0; i--) {
                sld[i] = max(sld[i], has[i] + p);
                has[i] = max(has[i], sld[i-1] - p);
            }
        }
        return sld[k];
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#188)

## 198. House Robber

The maximum value of non-adjacent elements in an array

数组中不相邻元素的最大值

**Example**

```
Input: nums = [1,2,3,1]
Output: 4

Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
```

---

### Cpp Solution
**分析：** 当前房间偷不偷取决于上上间加当前房间的价值和上一间的值哪个大。状态方程在下面。当然 如果看穿了以后就可以简化。处理 base case 更干净简单。

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int prev = 0, cur = 0;
        for (auto& num: nums) {
            prev = max(cur, prev + num);
            swap(cur, prev);
        }
        return max(prev, cur);
    }
};
```

### C Solution
**分析：**

```c
int rob(int *nums, int numsSize) {
    if (!numsSize) return 0;
    int prev = 0;
    int cur = *nums;
    
    int temp;
    for (int i = 1; i < numsSize; ++i) {
        temp = prev + nums[i];
        prev = cur;
        cur = temp > cur ? temp : cur;
    }
    return  cur;
}
```

[返回目录](#198)

## 213. House Robber II

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.



你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

**Example**

```
Input: [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),
             because they are adjacent houses.
```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
private:
    int helper(vector<int>& nums, int st, int ed) {
        int prev = 0, res = 0;
        for (int i = st; i < ed; i++) {
            prev = max(prev + nums[i], res);
            swap(prev, res);
        }
        return res;
    }

public:
    int rob(vector<int>& nums) {
        int len = nums.size();
        return max(helper(nums, len != 1, len), helper(nums, 0, len-1));
    }
};
```

### C Solution
**分析：** 把一个环, 分成两个就可以了, 代码更清楚

```c
int my_rob(int *nums, int numsSize) {
    int pre = 0;
    int cur = nums[0];
    for (int i = 1; i < numsSize; ++i) {
        int temp = pre + nums[i] > cur ? pre + nums[i] : cur;
        pre = cur;
        cur = temp;
    }
    return cur;
}

int rob(int *nums, int numsSize) {
    if (!numsSize) return 0;
    if (numsSize == 1) return nums[0];
    int res1, res2;
    return (res1 = my_rob(nums, numsSize - 1)) > (res2 = my_rob(++nums, numsSize - 1)) ? res1 : res2;
}
```

[返回目录](#213)

## 221. Maximal Square

Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.

在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

**Example**

```
Input: 

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

Output: 4
```

---

### Cpp Solution
**分析：** dp来累计状态，同样可以状态压缩。

```cpp
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.empty()) return 0;
        int m = matrix.size(), n = matrix[0].size();

        vector<int> dp(n);
        for (int j = 0; j < n; j++) dp[j] = matrix[0][j] == '1';

        int prev, cur, res = *max_element(dp.begin(), dp.end());

        for (int i = 1; i < m; i++) {
            prev = dp[0];
            dp[0] = matrix[i][0] == '1';
            for (int j = 1; j < n; j++) {
                cur = dp[j];
                if (matrix[i][j] == '1') {
                    dp[j] = min({prev, dp[j-1], dp[j]}) + 1;
                } else {
                    dp[j] = 0;
                }
                prev = cur;
            }
            res = max(res, *max_element(dp.begin(), dp.end()));
        }
        return res * res;
    }
};
```

### C Solution
**分析：**

```c
int maximalSquare(char **matrix, int matrixSize, int *matrixColSize) {
    int max_side = 0;
    if (!matrixSize) return max_side;
    int dp[matrixSize][*matrixColSize];

    for (int i = 0; i < matrixSize; ++i) {
        dp[i][0] = matrix[i][0] == '1' ? 1 : 0;
        max_side |= dp[i][0];
    }

    for (int j = 0; j < *matrixColSize; ++j) {
        dp[0][j] = matrix[0][j] == '1' ? 1 : 0;
        max_side |= dp[0][j];
    }

    int min3(int, int, int);
    for (int i = 1; i < matrixSize; ++i) {
        for (int j = 1; j < *matrixColSize; ++j) {
            if (matrix[i][j] == '0') dp[i][j] = 0;
            else {
                dp[i][j] = min3(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1;
                max_side = max_side > dp[i][j] ? max_side : dp[i][j];
            }
        }
    }
    return max_side * max_side;
}

int min3(int a, int b, int c) {
    a = a < b ? a : b;
    a = a < c ? a : c;
    return a;
}
```

[返回目录](#221)

## 256. Paint House

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#256)

## 264. Ugly Number II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        int j = 0, k = 0, l = 0;

        vector<int> dp(n);
        dp[0] = 1;

        for (int i = 1; i < n; i++) {
            while (dp[j] * 2 <= dp[i-1]) j++;
            while (dp[k] * 3 <= dp[i-1]) k++;
            while (dp[l] * 5 <= dp[i-1]) l++;
            dp[i] = min({dp[j] * 2, dp[k] * 3, dp[l] * 5});
        }
        return dp[n-1];
    }
};
```

### C Solution
**分析：**

```c
int nthUglyNumber(int n) {
    int dp[n];
    dp[0] = 1;
    int p2, p3, p5;
    p2 = p3 = p5 = 0;

    int min3(int, int, int);
    for (int i = 1; i < n; ++i) {
        dp[i] = min3(dp[p2] * 2, dp[p3] * 3, dp[p5] * 5);
        if (dp[i] == (dp[p2] * 2)) p2++;
        if (dp[i] == (dp[p3] * 3)) p3++;
        if (dp[i] == (dp[p5] * 5)) p5++;
    }
    return dp[n-1];
}

int min3(int x, int y, int z) {
    x = x < y ? x : y;
    x = x < z ? x : z;
    return x;
}
```

[返回目录](#264)

## 265. Paint House II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#265)

## 276. Paint Fence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#276)

## 279. Perfect Squares

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int numSquares(int n) {
        int dp[n+1];

        for (int i = 0; i <= n; i++) {
            dp[i] = i;
            for (int j = 1; j * j <= i; j++) {
                dp[i] = min(dp[i], dp[i-j*j] + 1);
            }
        }
        return dp[n];
    }
};
```

### C Solution
**分析：**

```c
int numSquares(int n) {
    int dp[n + 1];

    for (int i = 0; i < n + 1; i++) {
        dp[i] = i;                                  // 最坏情况下的个数，全部由1组成
        for (int j = 1; i - j * j >= 0; j++) {
            dp[i] = dp[i] < dp[i - j * j] + 1 ? dp[i] : dp[i - j * j] + 1;
        }
    }
    return dp[n];
}
```

[返回目录](#279)

## 300. Longest Increasing Subsequence

**Example**

```

```

---

### Cpp Solution
**分析：** 非常精彩的题目，常规动态规划解法是 O(n^2) 的时间复杂度，但是用二分搜索可以减少到 O(nlgn)，尤其是迭代更新的部分需要好好品味下。

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if (nums.empty()) return 0;

        int n = nums.size();
        vector<int> dp(n, 1);

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }
        return *max_element(dp.begin(), dp.end());
    }
};
```

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        if (n < 2) return n;

        vector<int> dp({nums[0]});
        for (int i = 1; i < n; i++) {
            if (nums[i] > dp.back()) {
                dp.push_back(nums[i]);
                continue;
            }

            int lo = 0, hi = dp.size() - 1, mid;
            while (lo < hi) {
                mid = lo + (hi - lo) / 2;
                if (nums[i] > dp[mid]) {
                    lo = mid + 1;
                } else {
                    hi = mid;
                }
            }
            dp[lo] = nums[i];
        }
        return dp.size();
    }
};
```

### C Solution
**分析：**

```c
int lengthOfLIS(int *nums, int numsSize) {
    if (numsSize == 0) return 0;
    int dp[numsSize];               // 至目前元素, 最长的子序列长度
    for (int i = 0; i < numsSize; i++)
        dp[i] = 1;

    int longest = 0;
    for (int i = 0; i < numsSize; i++) {
        for (int j = 0; j < i; j++)
            if (nums[j] < nums[i])
                dp[i] = dp[i] > dp[j] + 1 ? dp[i] : dp[j] + 1;

        longest = longest > dp[i] ? longest : dp[i];
    }
    return longest;
}
```

[返回目录](#300)

## 303. Range Sum Query - Immutable

**Example**

```

```

---

### Cpp Solution
**分析：** 前缀和，可以学习下partial_sum的使用方法

```cpp
class NumArray {
public:
    NumArray(vector<int> &nums) : psum(nums.size()+1, 0) {
        partial_sum( nums.begin(), nums.end(), psum.begin()+1);
    }

    int sumRange(int i, int j) {
        return psum[j+1] - psum[i];
    }

private:
    vector<int> psum;    
};
```

### C Solution
**分析：**

```c
typedef struct {
    int prefix_sum;
} NumArray;


NumArray* numArrayCreate(int* nums, int numsSize) {
    if (!numsSize) return NULL;
    NumArray *obj = (NumArray *) malloc(sizeof(NumArray) * numsSize);
    obj->prefix_sum = *nums;

    for (int i = 1; i < numsSize; ++i) {
        obj[i].prefix_sum = obj[i-1].prefix_sum + nums[i];
    }
    return obj;
}

int numArraySumRange(NumArray* obj, int i, int j) {  // 包前包后
    if (!i) return obj[j].prefix_sum;
    return obj[j].prefix_sum - obj[i-1].prefix_sum;
}

void numArrayFree(NumArray* obj) {
    free(obj);
}

```

[返回目录](#303)

## 304. Range Sum Query 2D - Immutable

**Example**

```

```

---

### Cpp Solution
**分析：** 上一题二维的情况，只需要分清边界条件

```cpp
class NumMatrix {
public:
    NumMatrix(vector<vector<int>>& matrix) {
        if (matrix.empty()) return;

        psum = vector<vector<int>>(matrix.size()+1, vector<int>(matrix[0].size()+1, 0));
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < matrix[0].size(); j++) {
                psum[i+1][j+1] = psum[i][j+1] + psum[i+1][j] - psum[i][j] + matrix[i][j];
            }
        }
    }

    int sumRegion(int row1, int col1, int row2, int col2) {
        return psum[row2+1][col2+1] - psum[row2+1][col1] - psum[row1][col2+1] + psum[row1][col1];
    }

private:
    vector<vector<int>> psum;
};
```

### C Solution
**分析：**

```c

```

[返回目录](#304)

## 309. Best Time to Buy and Sell Stock with Cooldown

**Example**

```

```

---

### Cpp Solution
**分析：** 分析清楚一共有 3 个状态，即持有、卖出、和冷却。对应状态对应操作即可。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int pre = 0, hld = INT_MIN, sld = 0, tmp;
        for (auto& p: prices) {
            tmp = sld;
            sld = max(sld, hld + p);
            hld = max(hld, pre - p);
            pre = tmp;
        }
        return sld;
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#309)

## 312. Burst Balloons

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#312)

## 321. Create Maximum Number

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#321)

## 322. Coin Change

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> need(amount+1, amount+1);
        need[0] = 0;

        for (int c : coins) {
            for (int a = c; a <= amount; a++) {
                need[a] = min(need[a], need[a-c] + 1);
            }
        }
        return need.back() > amount ? -1 : need.back();
    }
};
```

### C Solution
**分析：**

```c
int coinChange(int* coins, int coinsSize, int amount){
    int dp[amount + 1];
    int max = amount + 1;
    dp[0] = 0;
    for (int k = 1; k <= amount; ++k) {
        dp[k] = max;
    }

    for (int i = 1; i <= amount; ++i) {
        for (int j = 0; j < coinsSize; ++j) {
            if (coins[j] <= i) {
                dp[i] = dp[i-coins[j]]+1 < dp[i] ? dp[i-coins[j]]+1 : dp[i];
            }
        }
    }
    return dp[amount] > amount ? -1 : dp[amount];
}
```

[返回目录](#322)

## 338. Counting Bits

Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.

给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。

**Example**

```
Example 1:
Input: 2
Output: [0,1,1]

Example 2:
Input: 5
Output: [0,1,1,2,1,2]
```

---

### Cpp Solution
**分析：** 第一种解法有点类似于找规律但是可以将大数分解为小的部分进行求解。第二种解法就是根据数的二进制表示了。

```cpp
class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> dp(num+1);
        int cur = 0, last = 1;

        for (int i = 1; i <= num; i++) {
            dp[i] = dp[cur++] + 1;
            if (cur == last) {
                cur = 0;
                last = i + 1;
            }
        }
        return dp;
    }
};
```

```cpp
class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> ret(num+1, 0);
        for (int i = 1; i <= num; ++i)
            ret[i] = ret[i&(i-1)] + 1;
        return ret;
    }
};
```

### C Solution
**分析：**

```c
int *countBits(int num, int *returnSize) {
    int *dp = (int *) malloc(sizeof(int) * (num + 1));
    *dp = 0;

    for (int i = 1; i <= num; ++i) {
        if (!(i % 2))
            dp[i] = dp[i/2];
        else
            dp[i] = dp[i-1] + 1;
    }
    *returnSize = num+1;
    return dp;
}
```

[返回目录](#338)

## 343. Integer Break

Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.

给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

**Example**

```
Example 1:
Input: 2
Output: 1
Explanation: 2 = 1 + 1, 1 × 1 = 1.

Example 2:
Input: 10
Output: 36
Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.
```

---

### Cpp Solution
**分析：** 剑指 offer 中的 #14 剪绳子。动态规划或者数学论证。

```cpp
class Solution {
public:
    int integerBreak(int n) {
        int dp[n+1];
        memset(dp, 0, sizeof(dp));

        for (int i = 1; i <= n; i ++) {
            if (i < 4) {
                dp[i] = i - 1;
                continue;
            }

            for (int j = 1; j <= i / 2; j++) {
                dp[i] = max(dp[i], max(j, dp[j]) * max(i - j, dp[i-j]));
            }
        }
        return dp[n];
    }
};
```

```cpp
class Solution {
public:
    int integerBreak(int n) {
        if (n < 4) return n - 1;

        return pow(3, (n-2) / 3) *((n-2) % 3 + 2);
    }
};
```

### C Solution
**分析：**

```c
int integerBreak(int n){
    if (n < 2) return n;

    int dp[n+1];
    memset(dp, 0, sizeof(dp));
    dp[0] = 0;
    dp[1] = 1;

    int tmp;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j < i; ++j) {
            tmp = dp[j] > j ? dp[j] : j;
            dp[i] = dp[i] > tmp * (i-j) ? dp[i] : tmp * (i-j);
        }
    }

    return dp[n];
}
```

[返回目录](#343)

## 351. Android Unlock Patterns

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#351)

## 354. Russian Doll Envelopes

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#354)

## 357. Count Numbers with Unique Digits

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int countNumbersWithUniqueDigits(int n) {
        vector<int> dp(n+1);
        dp[0] = 1;

        for (int i = 1; i <= n; i++) {
            dp[i] = 9;
            for (int j = 0; j < i - 1; j++) {
                dp[i] *= 9 - j;
            }
            dp[i] += dp[i-1];
        }
        return dp[n];
    }
};
```

### C Solution
**分析：**

```c
int countNumbersWithUniqueDigits(int n){
    if (n > 10) return 0;
    int dp[n+1];
    dp[0] = 1;
    dp[1] = 10;

    for (int i = 2; i <= n; ++i) {
        dp[i] = 9;
        for (int j = 0; j < i-1; ++j) {
            dp[i] *= (9-j);
        }
        dp[i] += dp[i-1];
    }
    return dp[n];
}
```

[返回目录](#357)

## 361. Bomb Enemy

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#361)

## 363. Max Sum of Rectangle No Larger Than K

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#363)

## 368. Largest Divisible Subset

Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies:

Si % Sj = 0 or Sj % Si = 0.

If there are multiple solutions, return any subset is fine.

给出一个由无重复的正整数组成的集合，找出其中最大的整除子集，子集中任意一对 (Si，Sj) 都要满足：Si % Sj = 0 或 Sj % Si = 0。

如果有多个目标子集，返回其中任何一个均可。

**Example**

```
Example 1:
Input: [1,2,3]
Output: [1,2] (of course, [1,3] will also be ok)

Example 2:
Input: [1,2,4,8]
Output: [1,2,4,8]
```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    vector<int> largestDivisibleSubset(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> result(nums.size());
        vector<int> ret;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] % nums[j] == 0 && result[j].size() > result[i].size()) {
                    result[i] = result[j];
                }
            }
            result[i].push_back(nums[i]);
            if (ret.size() < result[i].size()) ret = result[i];
        }
        return ret;
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#368)

## 375. Guess Number Higher or Lower II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#375)

## 376. Wiggle Subsequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#376)

## 377. Combination Sum IV

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#377)

## 392. Is Subsequence

Given a string s and a string t, check if s is subsequence of t.

A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ace" is a subsequence of "abcde" while "aec" is not).

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

**Example**

```
Example 1:
Input: s = "abc", t = "ahbgdc"
Output: true

Example 2:
Input: s = "axc", t = "ahbgdc"
Output: false
```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int pos = 0;
        for (int i = 0; i < t.length(); i++) {
            if (s[pos] == t[i]) pos++;
        }
        return pos == s.length() - 1;
    }
};
```

### C Solution
**分析：**

```c
bool isSubsequence(char *s, char *t) {
    while (*t != '\0') {
        if (*s == '\0') return true;
        if (*t == *s) {
            s++;
        }
        t++;
    }

    if (*s == '\0') return true;
    return false;
}
```

[返回目录](#392)

## 403. Frog Jump

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#403)

## 410. Split Array Largest Sum

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#410)

## 413. Arithmetic Slices

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#413)

## 416. Partition Equal Subset Sum

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#416)

## 418. Sentence Screen Fitting

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#418)

## 446. Arithmetic Slices II - Subsequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#446)

## 464. Can I Win

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#464)

## 466. Count The Repetitions

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#466)

## 467. Unique Substrings in Wraparound String

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#467)

## 471. Encode String with Shortest Length

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#471)

## 472. Concatenated Words

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#472)

## 474. Ones and Zeroes

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        int dp[m+1][n+1];
        memset(dp, 0, sizeof(dp));

        for (auto& s: strs) {
            int n0 = 0, n1 = 0;
            for (char c: s) {
                c == '0' ? n0++ : n1++;
            }

            for (int i = m; i >= n0; i--) {
                for (int j = n; j >= n1; j--) {
                    dp[i][j] = max(dp[i][j], dp[i-n0][j-n1] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#474)

## 486. Predict the Winner

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#486)

## 494. Target Sum

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#494)

## 514. Freedom Trail

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#514)

## 516. Longest Palindromic Subsequence

**Example**

```

```

---

### Cpp Solution
**分析：** 实际为编辑距离的变形题 简单

```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.length(), pre, cur, dp[n+1];
        for (int j = 0; j <= n; j++) dp[j] = j;

        for (int i = 0; i < n; i++) {
            pre = dp[0]++;
            for (int j = 0; j < n; j++) {
                cur = dp[j+1];
                if (s[i] == s[n-j-1]) {
                    dp[j+1] = pre;
                } else {
                    dp[j+1] = 1 + min(dp[j], dp[j+1]);
                }
                pre = cur;
            }
        }
        return n - dp[n] / 2;
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#516)

## 517. Super Washing Machines

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#517)

## 523. Continuous Subarray Sum

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        if (n == 1) return false;
        if (k == 1) return true;

        if (k == 0) {
            for (int i = 0 ; i < n - 1 ; i++) {
                if(nums[i] == 0 && nums[i+1] == 0) return true;
            }
			return false;
        }

        vector<int> sum_map(n+1,0);
        unordered_map<int,int> history;
        for (int i = 0 ; i < n ;i++) sum_map[i+1] = (sum_map[i] + nums[i]) % k;
        history[sum_map[0]] = 1;
        history[sum_map[1]] = (sum_map[1] != sum_map[0]) + 1;

        for (int i = 2 ; i <= n ;i++) { 
            if (history[sum_map[i]] == 0)
                history[sum_map[i]] = i + 1;
            else if (i - history[sum_map[i]] > 0)
                return true;
        }
        return false;
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#523)

## 546. Remove Boxes

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#546)

## 552. Student Attendance Record II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#552)

## 568. Maximum Vacation Days

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#568)

## 576. Out of Boundary Paths

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#576)

## 600. Non-negative Integers without Consecutive Ones

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#600)

## 629. K Inverse Pairs Array

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#629)

## 638. Shopping Offers

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#638)

## 639. Decode Ways II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#639)

## 646. Maximum Length of Pair Chain

**Example**

```

```

---

### Cpp Solution
**分析：** 第一种动态规划 时间复杂度为 O(N^2)，第二种贪心算法, 时间复杂度为 O(NlogN)

```cpp
class Solution { // Dynamic Programming
public:
    int findLongestChain(vector<vector<int>>& pairs) {
        sort(pairs.begin(), pairs.end());

        int n = pairs.size();
        vector<int> dp(n, 1);

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (pairs[i][0] > pairs[j][1]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }
        return *max_element(dp.begin(), dp.end());
    }
};
```

```cpp
class Solution { // Greedy
public:
    int findLongestChain(vector<vector<int>>& pairs) {
        sort(pairs.begin(), pairs.end(),
            [](auto& a, auto& b) {
                return a[1] < b[1];
            });

        int cur = INT_MIN, res = 0;
        for (auto& p: pairs) {
            if (cur < p[0]) {
                cur = p[1];
                res++;
            }
        }
        return res;
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#646)

## 647. Palindromic Substrings

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#647)

## 650. 2 Keys Keyboard

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int minSteps(int n) {
        int s = 0;
        for (int d = 2; d <= n; d++) {
            while (n % d == 0) {
                s += d;
                n /= d;
            }
        }
        return s;
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#650)

## 651. 4 Keys Keyboard

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#651)

## 656. Coin Path

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#656)

## 664. Strange Printer

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#664)

## 673. Number of Longest Increasing Subsequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#673)

## 688. Knight Probability in Chessboard

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#688)

## 689. Maximum Sum of 3 Non-Overlapping Subarrays

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#689)

## 691. Stickers to Spell Word

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#691)

## 698. Partition to K Equal Sum Subsets

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#698)

## 712. Minimum ASCII Delete Sum for Two Strings

Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal.

给定两个字符串s1，s2，找到已删除字符的最低ASCII总和，以使两个字符串相等。

**Example**

```
Example 1:
Input: s1 = "sea", s2 = "eat"
Output: 231
Explanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum.
Deleting "t" from "eat" adds 116 to the sum.
At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.

Example 2:
Input: s1 = "delete", s2 = "leet"
Output: 403
Explanation: Deleting "dee" from "delete" to turn the string into "let",
adds 100[d]+101[e]+101[e] to the sum.  Deleting "e" from "leet" adds 101[e] to the sum.
At the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403.
If instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.
```

**Note:**

 - 0 < s1.length, s2.length <= 1000.
 - All elements of each string will have an ASCII value in [97, 122].

---

### Cpp Solution
**分析：** 其实是#72 编辑距离的 followup，一样的做法。还有一种最长上升子序列的做法，留待补充。
-- TODO

```cpp
class Solution {
public:
    int minimumDeleteSum(string s1, string s2) {
        int m = s1.length(), n = s2.length(), prev, cur;

        vector<int> dp(n+1);
        dp[0] = 0;
        for (int j = 0; j < n; j++) dp[j+1] = dp[j] + s2[j];

        for (int i = 0; i < m; i++) {
            prev = dp[0];
            dp[0] += s1[i];

            for (int j = 0; j < n; j++) {
                cur = dp[j+1];
                if (s1[i] == s2[j]) {
                    dp[j+1] = prev;
                } else {
                    dp[j+1] = min(dp[j] + s2[j], dp[j+1] + s1[i]);
                }
                prev = cur;
            }
        }
        return dp[n];
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#712)

## 714. Best Time to Buy and Sell Stock with Transaction Fee

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int hld = INT_MIN / 2, sld = 0, tmp;

        for (auto& p: prices) {
            tmp = sld;
            sld = max(sld, hld + p - fee);
            hld = max(hld, tmp - p);
        }
        return sld;
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#714)

## 718. Maximum Length of Repeated Subarray

Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.

给定两个整数数组A和B，返回出现在两个数组中的子数组的最大长度。

**Example**

```
Input:
A: [1,2,3,2,1]
B: [3,2,1,4,7]
Output: 3
Explanation: 
The repeated subarray with maximum length is [3, 2, 1].
```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int findLength(vector<int>& a, vector<int>& b) {
        int m = a.size(), n = b.size();
        if (!m || !n) return 0;

        int dp[n+1], res = 0;
        memset(dp, 0, sizeof(dp));
        for (int i = m - 1; i >= 0; i--) {
            for (int j = 0; j < n; j++) {
                if (a[i] == b[j]) {
                    dp[j] = dp[j + 1] + 1;
                    res = max(res, dp[j]);
                } else {
                    dp[j] = 0;
                }
            }
        }
        return res;
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#718)

## 727. Minimum Window Subsequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#727)

## 730. Count Different Palindromic Subsequences

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#730)

## 740. Delete and Earn

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#740)

## 741. Cherry Pickup

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#741)

## 746. Min Cost Climbing Stairs

**Example**

```

```

---

### Cpp Solution
**分析：** 打家劫舍的问题，但是由于限制了数据范围，不用错误判断，更简单了。

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int prev = cost[0], cur = cost[1];
        for (int i = 2; i < cost.size(); i++) {
            prev = cost[i] + min(prev, cur);
            swap(prev, cur);
        }
        return min(prev, cur);
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#746)

## 750. Number Of Corner Rectangles

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#750)

## 764. Largest Plus Sign

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#764)

## 787. Cheapest Flights Within K Stops

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#787)

## 790. Domino and Tromino Tiling

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#790)

## 801. Minimum Swaps To Make Sequences Increasing

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#801)

## 808. Soup Servings

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#808)

## 813. Largest Sum of Averages

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    double largestSumOfAverages(vector<int>& A, int K) {
        if (!K || A.empty()) return 0;

        int n = A.size();

        double dp[K+1][n];
        memset(dp, 0, sizeof(dp));

        int sum[n];
        for (int i = 0; i < n; i++) {
            sum[i] = A[i] + (i ? sum[i-1] : 0);
        }

        for (int k = 1; k <= K; k++) {
            for (int i = k - 1; i < n; i++) {
                if (k == 1) {
                    dp[k][i] = double(sum[i]) / (i + 1);
                    continue;
                }

                for (int j = k - 2; j < i; j++) {
                    dp[k][i] = max(dp[k][i],
                                   dp[k-1][j] + double(sum[i] - sum[j]) / (i - j));
                }
            }
        }
        return dp[K][n-1];
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#813)

## 818. Race Car

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#818)

## 837. New 21 Game

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#837)

## 838. Push Dominoes

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    string pushDominoes(string dominoes) {
        int n = dominoes.length();
        if (!n) return dominoes;

        vector<int> dp(n, 0);
        for (int i = 0, tmp = 0; i < n; i++) {
            if (dominoes[i] == 'R') {
                tmp = n;
            } else if (dominoes[i] == 'L') {
                tmp = 0;
            } else {
                tmp = max(tmp - 1, 0);
            }
            dp[i] += tmp;
        }
        for (int i = n - 1, tmp = 0; i >= 0; i--) {
            if (dominoes[i] == 'L') {
                tmp = n;
            } else if (dominoes[i] == 'R') {
                tmp = 0;
            } else {
                tmp = max(tmp - 1, 0);
            }
            dp[i] -= tmp;
        }

        string res = "";
        for (int i = 0; i < n; i++) {
            res += !dp[i] ? '.' : (dp[i] > 0 ? 'R' : 'L');
        }
        return res;
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#838)

## 847. Shortest Path Visiting All Nodes

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#847)

## 871. Minimum Number of Refueling Stops

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#871)

## 873. Length of Longest Fibonacci Subsequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#873)

## 877. Stone Game

**Example**

```

```

---

### Cpp Solution
**分析：** 智商题，实际上动态规划也可以做，但没必要。计算奇数位和、偶数位和，根据大的那个对应地拿就能赢。所以一定能赢

```cpp
class Solution {
public:
    bool stoneGame(vector<int>& piles) {
        return true;
    }
};
```

### C Solution
**分析：**

```c
bool stoneGame(int* piles, int pilesSize){
    return true;
}
```

[返回目录](#877)

## 879. Profitable Schemes

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#879)

## 887. Super Egg Drop

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#887)

## 898. Bitwise ORs of Subarrays

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#898)

## 902. Numbers At Most N Given Digit Set

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#902)

## 903. Valid Permutations for DI Sequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#903)

## 920. Number of Music Playlists

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#920)

## 931. Minimum Falling Path Sum

Given a square array of integers A, we want the minimum sum of a falling path through A.

A falling path starts at any element in the first row, and chooses one element from each row.  The next row's choice must be in a column that is different from the previous row's column by at most one.

给定整数A的方形数组，我们希望通过A的下降路径的总和最小。

下降路径从第一行的任何元素开始，并从每一行中选择一个元素。 下一行的选择必须在与上一行的列最多相差一列的列中。

**Example**

```
Input: [[1,2,3],[4,5,6],[7,8,9]]
Output: 12
Explanation: 
The possible falling paths are:
  * [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]
  * [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]
  * [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]
The falling path with the smallest sum is [1,4,7], so the answer is 12.
```

**Constraints:**
- 1 <= A.length == A[0].length <= 100
- -100 <= A[i][j] <= 100

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& A) {
        vector<vector<int>> B(A);
        int n = B.size();

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < n; j++) {
                B[i][j] += min({B[i-1][max(0, j-1)],
                                B[i-1][j],
                                B[i-1][min(n-1, j+1)]});
            }
        }
        return *min_element(B[n-1].begin(), B[n-1].end());
    }
};
```

### C Solution
**分析：**

```c
int min2(int x, int y) {
    return x < y ? x : y;
}

int min3(int x, int y, int z) {
    return min2(min2(x, y), z);
}

int minFallingPathSum(int** A, int ASize, int* AColSize){
    int col_size = *AColSize;
    int dp[ASize][col_size];
    for (int i = 0; i < col_size; ++i) {
        dp[0][i] = A[0][i];
    }

    for (int i = 1; i < ASize; ++i) {
        for (int j = 0; j < col_size; ++j) {
            if (!j) {
                dp[i][j] = A[i][j] + min2(dp[i-1][j], dp[i-1][j+1]);
            } else if (j == col_size-1) {
                dp[i][j] = A[i][j] + min2(dp[i-1][j], dp[i-1][j-1]);
            } else {
                dp[i][j] = A[i][j] + min3(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]);
            }
        }
    }

    int res = dp[ASize-1][0];
    for (int k = 1; k < col_size; ++k) {
        res = min2(res, dp[ASize-1][k]);
    }
    return res;
}
```

[返回目录](#931)

## 935. Knight Dialer

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#935)

## 940. Distinct Subsequences II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#940)

## 943. Find the Shortest Superstring

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#943)

## 956. Tallest Billboard

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#956)

## 960. Delete Columns to Make Sorted III

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#960)

## 964. Least Operators to Express Number

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#964)

## 967. Numbers With Same Consecutive Differences

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#967)

## 968. Binary Tree Cameras

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#968)

## 975. Odd Even Jump

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#975)

## 978. Longest Turbulent Subarray

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#978)

## 982. Triples with Bitwise AND Equal To Zero

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#982)

## 983. Minimum Cost For Tickets

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int n = days.size();
        vector<int> dp(n+1);

        for (int i = 0, w = 0, m = 0; i < n; i++) {
            while (days[i] - days[w] >= 7) w++;
            while (days[i] - days[m] >= 30) m++;
            dp[i+1] = min({dp[i] + costs[0],
                           dp[w] + costs[1],
                           dp[m] + costs[2]});
        }
        return dp[n];
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#983)

## 1000. Minimum Cost to Merge Stones

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1000)

## 1055. Shortest Way to Form String

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1055)

## 1058. Minimize Rounding Error to Meet Target

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1058)

## 1012. Numbers With Repeated Digits

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1012)

## 1066. Campus Bikes II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1066)

## 1067. Digit Count in Range

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1067)

## 1024. Video Stitching

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1024)

## 1025. Divisor Game

**Example**

```

```

---

### Cpp Solution
**分析：** 动态规划或者数学题

```cpp
class Solution {
public:
    bool divisorGame(int N) {
        int dp[N+1];
        memset(dp, 0, sizeof(dp));

        for (int i = 2; i <= N; i++) {
            for (int j = 1; j < i; j++) {
                if (i % j == 0 && !dp[i-j]) {
                    dp[i] = 1;
                }
            }
        }
        return dp[N];
    }
};
```

```cpp
class Solution {
public:
    bool divisorGame(int N) {
        return N % 2 == 0;
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#1025)

## 1027. Longest Arithmetic Sequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1027)

## 1136. Parallel Courses

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1136)

## 1039. Minimum Score Triangulation of Polygon

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1039)

## 1048. Longest String Chain

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1048)

## 1049. Last Stone Weight II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1049)

## 1074. Number of Submatrices That Sum to Target

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1074)

## 1230. Toss Strange Coins

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1230)

## 1199. Minimum Time to Build Blocks

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1199)

## 1092. Shortest Common Supersequence

**Example**

```

```

---

### Cpp Solution
**分析：** 第一种做法是延续 LCS 的做法，也是比较容易想到的做法，但是时间很慢可以优化。优化的点在于字符串的拼接，可以参考第二种做法拼凑出 LCS 。

```cpp
class Solution {
public:
    string shortestCommonSupersequence(string str1, string str2) {
        int i = 0, j = 0;

        string res = "", lcs = longestCommonSubsequence(str1, str2);
        for (char c: lcs) {
            while (str1[i] != c) {
                res += str1[i++];
            }
            while (str2[j] != c) {
                res += str2[j++];
            }
            res += c, i++, j++;
        }
        return res + str1.substr(i) + str2.substr(j);
    }

private:
    string longestCommonSubsequence(string& str1, string& str2) {
        int m = str1.length(), n = str2.length();
        vector<string> dp(n+1, "");

        string pre, cur;
        for (int i = 0; i < m; i++) {
            pre = dp[0];
            for (int j = 0; j < n; j++) {
                cur = dp[j+1];
                if (str1[i] == str2[j]) {
                    dp[j+1] = pre + str1[i];
                } else {
                    dp[j+1] = dp[j].length() > dp[j+1].length() ? dp[j] : dp[j+1];
                }
                pre = cur;
            }
        }
        return dp[n];
    }
};
```

```cpp
class Solution {
public:
    string shortestCommonSupersequence(string str1, string str2) {
        int i = 0, j = 0;

        string res = "", lcs = longestCommonSubsequence(str1, str2);
        for (char c: lcs) {
            while (str1[i] != c) {
                res += str1[i++];
            }
            while (str2[j] != c) {
                res += str2[j++];
            }
            res += c, i++, j++;
        }
        return res + str1.substr(i) + str2.substr(j);
    }

private:
    string longestCommonSubsequence(string& str1, string& str2) {
        int m = str1.length(), n = str2.length(), dp[m+1][n+1];
        memset(dp, 0, sizeof(dp));

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (str1[i] == str2[j]) {
                    dp[i+1][j+1] = dp[i][j] + 1;
                } else {
                    dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1]);
                }
            }
        }

        string lcs_res = "";
        int i = m, j = n;
        while(i > 0 && j > 0) {
            if (str1[i-1] == str2[j-1]) {
                lcs_res.push_back(str1[i-1]);
                i--, j--;
            } else {
                dp[i-1][j] > dp[i][j-1]) ? i-- : j--;
            }
        }
        reverse(lcs_res.begin(), lcs_res.end());
        return lcs_res;
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#1092)

## 1216. Valid Palindrome III

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1216)

## 1105. Filling Bookcase Shelves

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1105)

## 1273. Delete Tree Nodes

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1273)

## 1246. Palindrome Removal

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1246)

## 1259. Handshakes That Don't Cross

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1259)

## 1125. Smallest Sufficient Team

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1125)

## 1289. Minimum Falling Path Sum II

Given a square grid of integers arr, a falling path with non-zero shifts is a choice of exactly one element from each row of arr, such that no two elements chosen in adjacent rows are in the same column.

Return the minimum sum of a falling path with non-zero shifts.

给定一个整数的正方形网格，具有非零位移的下降路径可以选择arr每行中的一个元素，这样在相邻列中没有两个元素被选择在同一列中。

返回非零位移的下降路径的最小和。

**Example**

```
Input: arr = [[1,2,3],[4,5,6],[7,8,9]]
Output: 13
Explanation:
The possible falling paths are:
[1,5,9], [1,5,7], [1,6,7], [1,6,8],
[2,4,8], [2,4,9], [2,6,7], [2,6,8],
[3,4,8], [3,4,9], [3,5,7], [3,5,9]
The falling path with the smallest sum is [1,5,7], so the answer is 13.
```

**Constraints:**

 - 1 <= arr.length == arr[i].length <= 200
 - -99 <= arr[i][j] <= 99

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    vector<int> find_1st_and_2nd_min(vector<int> &v)
    {
        vector<int> res = {-1, -1};
        int fmin = INT_MAX, smin = INT_MAX;
        for (int i = 0; i < v.size(); i++)
        {
            if (fmin > v[i])
            {
                smin = fmin;
                res[1] = res[0];
                fmin = v[i];
                res[0] = i;
            }
            else if (smin > v[i])
            {
                smin = v[i];
                res[1] = i;
            }
        }
        return res;

    }
    int minFallingPathSum(vector<vector<int>>& v) {
        int n = v.size();
        for (int i = n - 2; i >= 0; i--)
        {
            vector<int> res = find_1st_and_2nd_min(v[i+1]);
            for (int j = 0; j < n; j++)
            {
                v[i][j] += v[i+1][res[0] != j ? res[0] : res[1]];
            }
        }
        return *min_element(v[0].begin(), v[0].end());
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#1289)

## 1130. Minimum Cost Tree From Leaf Values

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1130)

## 1301. Number of Paths with Max Score

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1301)

## 1139. Largest 1-Bordered Square

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1139)

## 1140. Stone Game II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1140)

## 1314. Matrix Block Sum

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1314)

## 1143. Longest Common Subsequence

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.length(), n = text2.length();

        int dp[n+1], pre, cur;
        memset(dp, 0, sizeof(dp));

        for (int i = 0; i < m; i++) {
            pre = dp[0];
            for (int j = 0; j < n; j++) {
                cur = dp[j+1];
                if (text1[i] == text2[j]) {
                    dp[j+1] = pre + 1;
                } else {
                    dp[j+1] = max(dp[j], dp[j+1]);
                }
                pre = cur;
            }
        }
        return dp[n];
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#1143)

## 1147. Longest Chunked Palindrome Decomposition

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1147)

## 1155. Number of Dice Rolls With Target Sum

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1155)

## 1363. Largest Multiple of Three

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1363)

## 1425. Constrained Subsequence Sum

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1425)

## 1186. Maximum Subarray Sum with One Deletion

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1186)

## 1187. Make Array Strictly Increasing

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1187)

## 1483. Kth Ancestor of a Tree Node

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1483)

## 1191. K-Concatenation Maximum Sum

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1191)

## 1405. Longest Happy String

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1405)

## 1218. Longest Arithmetic Subsequence of Given Difference

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1218)

## 1220. Count Vowels Permutation

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1220)

## 1223. Dice Roll Simulation

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1223)

## 1235. Maximum Profit in Job Scheduling

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1235)

## 1240. Tiling a Rectangle with the Fewest Squares

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1240)

## 1227. Airplane Seat Assignment Probability

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1227)

## 1262. Greatest Sum Divisible by Three

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1262)

## 1269. Number of Ways to Stay in the Same Place After Some Steps

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1269)

## 1277. Count Square Submatrices with All Ones

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp
class Solution {
public:
    int countSquares(vector<vector<int>>& matrix) {
        if (matrix.empty()) return 0;
        int m = matrix.size(), n = matrix[0].size();

        vector<int> dp(matrix[0]);
        int res = accumulate(dp.begin(), dp.end(), 0), prev, cur;

        for (int i = 1; i < m; i++) {
            prev = dp[0];
            dp[0] = matrix[i][0];
            for (int j = 1; j < n; j++) {
                cur = dp[j];
                if (matrix[i][j]) {
                    dp[j] = min({prev, dp[j-1], dp[j]}) + 1;
                } else {
                    dp[j] = 0;
                }
                prev = cur;
            }
            res += accumulate(dp.begin(), dp.end(), 0);
        }
        return res;
    }
};
```

### C Solution
**分析：**

```c

int min3(int x,int y, int z) {
    x = x < y ? x : y;
    x = x < z ? x : z;
    return x;
}
int countSquares(int** matrix, int matrixSize, int* matrixColSize){
    int res = 0;

    for (int i = 0; i < matrixSize; ++i) {
        for (int j = 0; j < *matrixColSize; res += matrix[i][j++]) {
            if (matrix[i][j] && i && j)
                matrix[i][j] += min3(matrix[i-1][j-1], matrix[i-1][j], matrix[i][j-1]);
        }
    }
    return res;
}
```

[返回目录](#1277)

## 1278. Palindrome Partitioning III

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1278)

## 1312. Minimum Insertion Steps to Make a String Palindrome

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1312)

## 1320. Minimum Distance to Type a Word Using Two Fingers

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1320)

## 1326. Minimum Number of Taps to Open to Water a Garden

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1326)

## 1335. Minimum Difficulty of a Job Schedule

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1335)

## 1359. Count All Valid Pickup and Delivery Options

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1359)

## 1339. Maximum Product of Splitted Binary Tree

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1339)

## 1340. Jump Game V

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1340)

## 1349. Maximum Students Taking Exam

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1349)

## 1372. Longest ZigZag Path in a Binary Tree

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1372)

## 1373. Maximum Sum BST in Binary Tree

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1373)

## 1367. Linked List in Binary Tree

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1367)

## 1388. Pizza With 3n Slices

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1388)

## 1402. Reducing Dishes

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1402)

## 1397. Find All Good Strings

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1397)

## 1416. Restore The Array

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1416)

## 1406. Stone Game III

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1406)

## 1411. Number of Ways to Paint N × 3 Grid

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1411)

## 1434. Number of Ways to Wear Different Hats to Each Other

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1434)

## 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1420)

## 1423. Maximum Points You Can Obtain from Cards

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1423)

## 1449. Form Largest Integer With Digits That Add up to Target

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1449)

## 1444. Number of Ways of Cutting a Pizza

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1444)

## 1463. Cherry Pickup II

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1463)

## 1458. Max Dot Product of Two Subsequences

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1458)

## 1478. Allocate Mailboxes

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1478)

## 1477. Find Two Non-overlapping Sub-arrays Each With Target Sum

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1477)

## 1473. Paint House III

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1473)

## 1510. Stone Game IV

**Example**

```

```

---

### Cpp Solution
**分析：**

```cpp

```

### C Solution
**分析：**

```c

```

[返回目录](#1510)

## 1504. Count Submatrices With All Ones

**Example**

```

```

---

### Cpp Solution
**分析：** 首先想到的就是暴力解法，遍历每一个为 1 的点，然后开始展开，计数全为 1 的矩阵。

```cpp
class Solution {
public:
    int numSubmat(vector<vector<int>>& mat) {
        int m = mat.size(), n = mat[0].size(), res = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (mat[i][j]) {
                    res += helper(mat, i, j, m, n);
                }
            }
        }
        return res;
    }

private:
    int helper(vector<vector<int>>& mat, int x, int y, int m, int n) {
        int  st = x, bound = n, cnt = 0;

        for (int i = x; i < m; i++) {
            for (int j = y; j < bound; j++) {
                if (mat[i][j]) {
                    cnt++;
                } else {
                    bound = j;
                }
            }
        }
        return cnt;
    }
};
```

### C Solution
**分析：**

```c

```

[返回目录](#1504)
